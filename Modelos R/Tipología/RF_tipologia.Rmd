---
title: "Accidentes - Random Forest"
output:
  html_document: default
  pdf_document: default
---

##Tabla accidentes 

Se hace la conexión con R

```{r}

#install.packages("RPostgreSQL")
require("RPostgreSQL")

# Guardar el Password para poder posteriormente eliminarlo
pw <- {"ludo"}

# Leer el driver de PostgreSQL
drv <- dbDriver("PostgreSQL")

# Crear la conexion con la base de datos
con <- dbConnect(drv, dbname = "accidentes_barcelona",
                 host = "192.168.0.165", port = 5432,
                 user = "postgres", password = pw)

# Eliminar el Password
rm(pw) 

# Chequear que existe la tabla de la base de datos para comprobar la conexión
dbExistsTable(con, "accidente")

```


Se importan los paquetes más genéricos

```{r}
library(readr)
library(ISLR)
library(ggplot2)
library(caret)
library(dplyr)
library(magrittr)
library(tidyverse)
library(rpart)
library(rpart.plot)
library(hydroTSM)
library(randomForest)
library(randomForestExplainer)
```

Se importa la data de la tabla de accidentes 

```{r}
accidente<- dbGetQuery(con, "SELECT * FROM accidente")
head(accidente)
```


Se hace un join para conocer el nombre del distrito y la fecha: 

```{r}
datos <- dbGetQuery(con, 
                    "SELECT *
FROM accidente
INNER JOIN descripcion_distrito_accidente ON accidente.id_desc_distrito = descripcion_distrito_accidente.id_desc_distrito
INNER JOIN descripcion_fecha_accidente_y_su_clima ON accidente.id_desc_fecha=descripcion_fecha_accidente_y_su_clima.id_desc_fecha
INNER JOIN tipologia_accidente ON accidente.num_expediente = tipologia_accidente.num_expediente
INNER JOIN descripcion_tipologia_accidente ON tipologia_accidente.id_desc_tipologia = descripcion_tipologia_accidente.id_desc_tipologia") 

head(datos)
```

Se seleccionan las columnas que voy a utilizar:

```{r}
datos1<- datos[,c("desc_distrito", "desc_fecha","id_desc_dia_semana", "hora", "desc_tipologia")]
head(datos1)
```

Para buscar los días de la semana: 

```{r}
dia_sem <-dbGetQuery(con, "SELECT * FROM descripcion_dia_semana_accidente")
dia_sem
```

Como se puede observar no están ordenados por lo que se procede a ordenarlos:

```{r}
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 1, 7, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 2, 1, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 3, 3, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 4, 5, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 5, 4, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 6, 2, datos1$id_desc_dia_semana)
datos1$id_desc_dia_semana<-ifelse(datos1$id_desc_dia_semana == 7, 6, datos1$id_desc_dia_semana)
```


También se determina si es de madrugada, mañana, tarde o noche:

```{r}
for(i in 1:nrow(datos1))
  {
  if      (datos1$hora[i] < 7.0)  { datos1$horario[i]<-"madrugada"} 
  else if (datos1$hora[i] >= 19.0){ datos1$horario[i]<-"noche"}
  else if (datos1$hora[i] >= 13.0){ datos1$horario[i]<-"tarde"}
  else                            { datos1$horario[i]<-"mañana"}
  }

head(datos1)
```

Se seleccionan las columnas que se van a utilizar

```{r}
datos2<-datos1[,c("desc_distrito","id_desc_dia_semana", "horario", "desc_tipologia")]
head(datos2)
```


Se transforma en factor

```{r}
datos2$id_desc_dia_semana<-as.factor(datos2$id_desc_dia_semana)
datos2$desc_tipologia<-as.factor(datos2$desc_tipologia)
datos2$horario<-as.factor(datos2$horario)
datos2$desc_distrito<-as.factor(datos2$desc_distrito)
```

```{r}
datos3 <- datos2 %>%
  group_by(desc_distrito,id_desc_dia_semana, horario, desc_tipologia) %>%
  summarise(cant_distritos=n())
```


Se estudian las variables 
```{r}
str(datos3)
```

Se soluciona el inconveniente con los NAs

```{r}
for (i in 1:4) datos[sample(150, sample(20)), i] <- NA
iris.roughfix <- na.roughfix(datos2)
```



Se parte el dataset en 2 grupos para trabajar entrenamiento y validación

```{r}
set.seed(12)

```

```{r}
smp_size <- floor(0.75 * nrow(datos3))

set.seed(123)
train_ind <- sample(seq_len(nrow(datos3)), size = smp_size)

train <- datos3[train_ind, ]
test <- datos3[-train_ind, ]
```

Ahora se plantea el modelo

```{r}
model.rf <- randomForest(formula = desc_tipologia ~ desc_distrito + horario + id_desc_dia_semana, importance = TRUE ,data = train, na.action=na.roughfix)
varImpPlot(model.rf)
```

Se hace un resumen con los resultados del modelo: 

```{r}
summary(model.rf)
```

Para observar las variables más importantes:

```{r}
importance(model.rf)
```



Se hace el estudio con Random Explainer

```{r}
min_depth_frame <- min_depth_distribution(model.rf)
save(min_depth_frame, file = "min_depth_frame.rda")
load("min_depth_frame.rda")
head(min_depth_frame, n = 10)
```



```{r}
plot_min_depth_distribution(min_depth_frame)
```


```{r}
importance_frame <- measure_importance(model.rf)
save(importance_frame, file = "importance_frame.rda")
load("importance_frame.rda")
importance_frame

```

```{r}
plot_multi_way_importance(importance_frame, size_measure = "no_of_nodes")
```


```{r}
plot_importance_ggpairs(importance_frame)
```

```{r}
explain_forest(model.rf, interactions = TRUE, data = datos3)
```



```{r}
preds <- predict(model.rf,data = train)
real <- train$cant_distritos
plot(real, preds)
```

```{r}
RMSE <- sqrt(mean((real - preds)^2))
RMSE
```



